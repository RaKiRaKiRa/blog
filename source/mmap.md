## 定义
Linux通过**将一个虚拟内存区域与一个磁盘上的对象**(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为**内存映射**(memory mapping)

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091416074054.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JhS2lSYUtpUmE=,size_16,color_FFFFFF,t_70)
 在Linux中，VM系统通过**将虚拟内存分割为称作虚拟页**(Virtual Page，VP)大小固定的块来处理磁盘(较低层)与上层数据的传输，一般情况下，每个页的大小默认是4096字节。同样的，**物理内存也被分割为物理页**(Physical Page，PP)，也为4096字节。
在mmap之后，**并没有在将文件内容加载到物理页上，只上在虚拟内存中分配了地址空间**。当进程在**访问这段地址时**（通过mmap在写入或读取时FileA），若虚拟内存对应的page没有在物理内存中缓存，则**产生"缺页"**，由内核的缺页异常处理程序处理，**将文件对应内容，以页为单位(4096)加载到物理内存**，注意是只加载缺页，但也会受操作系统一些调度策略影响，加载的比所需的多，这里就不展开了。缺页的简易视图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190914160833975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JhS2lSYUtpUmE=,size_16,color_FFFFFF,t_70)
## 详细原理：
*（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域*
1、进程**在用户空间调用库函数mmap**，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)；
2、在当前进程的虚拟地址空间中，**寻找一段空闲的连续的虚拟地址**；
3、为此虚拟区**分配一个vm_area_struct结构**，接着对这个结构的各个域进行了初始化；
4、将新建的虚拟区结构（vm_area_struct）**插入进程的虚拟地址区域链表或树中mm->mmap**；
 
*（二）调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系*
5、为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，**通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file）**，每个文件结构体维护着和这个已打开文件相关各项信息。
6、通过该文件的文件结构体，**链接到file_operations模块，调用内核函数mmap**，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
7、内核mmap函数**通过虚拟文件系统inode模块定位到文件磁盘物理地址**。
8、通过remap_pfn_range函数**建立页表**，即实现了文件地址和虚拟地址区域的映射关系。**此时，这片虚拟地址并没有任何数据关联到主存中。**

*（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝*
*注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。*
9、进程的读或写操作**访问虚拟地址空间这一段映射地址时**，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此**引发缺页异常**。
10、缺页异常进行一系列判断，确定无非法操作后，**内核发起请求调页过程**。
11、调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数**把所缺的页从磁盘装入到主存中**。
12、之后进程即可对这片主存进行读或者写的操作，**如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址**，也即完成了写入到文件的过程。
*注：修改过的脏页面并不会立即更新回文件中，而是有一段时间的延迟，可以调用msync()来强制同步, 这样所写的内容就能立即保存到文件里了。*

##	mmap相对于write/read的好处
read/write原理：
1、进程发起读文件请求。
2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。
3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。
4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘复制到页缓存。 **（主要不同）** 之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。

总结来说，**常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制**。这样造成读文件时需要**先将文件页从磁盘拷贝到页缓存**中，由于**页缓存处在内核空间，不能被用户进程直接寻址**，所以**还需要将页缓存中数据页再次拷贝到内存对应的用户空间中**。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。
总而言之，**常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝**。

而使用**mmap读取文件**中，创建新的虚拟内存区域和建立文件磁盘地址和虚拟内存区域映射这两步，**没有任何文件拷贝操作**。而之后访问数据时发现内存中并无数据而发起的**缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝**，就从磁盘中将数据传入内存的用户空间中，供进程使用。
mmap与read都需要两次上下文切换，都需要把文件拷贝到内核缓冲区，但mmap不需要将数据从内核拷贝到用户，而read需要
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190914160714609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JhS2lSYUtpUmE=,size_16,color_FFFFFF,t_70)
写操作也是一样，**待写入的buffer在内核空间不能直接访问**，必须要**先拷贝至内核空间对应的主存**（kernel buffer），**再写回磁盘中**（延迟写回），也是需要两次数据拷贝。
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190914160910634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JhS2lSYUtpUmE=,size_16,color_FFFFFF,t_70)
**mmap时，写入文件流程**：
Step1：进程(用户态)将需要写入的数据直接copy到对应的mmap地址(内存copy)
Step2：
	2.1) 若mmap地址未对应物理内存，则产生缺页异常，由内核处理
	2.2) 若已对应，则直接copy到对应的物理内存
Step3：由操作系统调用，将脏页回写到磁盘（通常这是异步的）

总而言之，**常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝**。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。说白了，mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。



mmap系统调用与read/write调用的区别在于：
1.	mmap只需要一次系统调用，后续操作不需要系统调用
2.	访问的数据不需要在page cache和用户缓冲区之间拷贝
3.	mmap与read都需要两次上下文切换，都需要把文件拷贝到内核缓冲区，但mmap不需要将数据从内核拷贝到用户，而read需要

