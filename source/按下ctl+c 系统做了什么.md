**信号的处理的实质是维护进程PCB中的特定数据**：Block 表、Pending 表和 handler 表。

Block意味着只要这个位图中对应位有效后，对应的信号就被阻塞，无法正常递达， 
pending表的代表的意思是，信号我已经收到，但是还没有递达到正确位置，从内核态转为用户态时，信号会抵达。 
handler表代表的意思是每个信号对应的处理方式。假如我们捕捉信号，自定义信号处理动作，则对应的handler表就会发生变化。

这三个表都是**使用位图实现**的，为了解释上述结构，首先明确以下概念
**抵达**：信号发送成功后实际执⾏信号的处理动作
**未决**：信号从产⽣到递达之间的状态
**阻塞**：标记信号暂时不应被处理（”人为暂停某个信号的处理“）

一般来讲，**被阻塞的信号产⽣时将保持在未决状态**,直到进程解除对此信号的阻塞,才执⾏递达的动作。
当一个信号进入阻塞态后，在阻塞状态被修改前永远不会执行对应的方法。
信号从产生到抵达总是伴随着 用户态与内核态的相互转换（高权限的任务由内核完成）
一般情况下的未决（没有被阻塞），正是表示信号产生「但内核还未转换到用户态」时的状态。
常规信号在递达之前产⽣多次只计⼀次,⽽实时信号在递达之前产⽣多次可以依次放在⼀个队列⾥。

对于2号信号（SIG_INT）/9号信号（SIG_KILL）
1. ⽤户输⼊命令,在Shell下启动⼀个前台进程。 
2. ⽤户按下Ctrl-C/输入对应kill,这个键盘输⼊**产⽣⼀个硬件中断**。 
3. 如果CPU当前正在执⾏这个进程的代码,则该进程的⽤户空间代码暂停执⾏,CPU从⽤户态**切换到内核态处理硬件中断**。 
4. 终端驱动程序将Ctrl-C / KILL解释成⼀个SIGINT/SIGKILL信号,**记在该进程的PCB中(也可以说发送了⼀个SIGINT信号给该进程)**。 
5. 当某个时刻要从内核返回到该进程的⽤户空间代码继续执⾏之前,⾸先处理PCB中记录的信号,发现有⼀个SIGINT/SIGKILL信号待处理,⽽**这个信号的默认处理动作是终⽌进程**,所以直接终⽌进程⽽不再返回它的⽤户空间代码执⾏。

